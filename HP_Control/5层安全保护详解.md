# 5层安全保护机制详解

## 概述

平台无关化后，虽然控制算法移至PC端，但**所有硬件级安全保护都保留在嵌入式端**，确保系统安全可靠。这5层保护在 `Task_50ms_SafetyCheck()` 中每50ms执行一次。

---

## 🛡️ 第1层：超压保护

### 触发条件
```c
if (Sensor_GetOilPressure() > 45.0f)
```
- 油压超过 **45 MPa** 时触发
- 正常工作范围：0-40 MPa
- 留有5 MPa安全余量

### 响应措施
```c
ValveControl_SetBypassValve(100.0f);  // 旁通阀全开（100%）
ValveControl_SetDirectionalValve(false);  // 换向阀关闭
```

### 工作原理
1. **旁通阀全开**：液压油通过旁通阀直接回流，释放压力
2. **关闭换向阀**：停止换向动作，避免压力继续升高
3. **效果**：快速降低系统压力，防止设备损坏

### 响应时间
- **检测周期**：50ms
- **执行时间**：<1ms（PWM+GPIO直接控制）
- **总响应时间**：<51ms

### 应用场景
- 系统异常导致压力失控
- 传感器短时故障误读高压
- 外部负载突然变化

---

## 🌡️ 第2层：超温保护

### 触发条件
```c
if (Sensor_GetOilTemperature() > 120.0f)
```
- 油温超过 **120°C** 时触发
- 正常工作范围：-20°C ~ 90°C
- 高温预警：90°C（PC端处理）
- 极限保护：120°C（硬件保护）

### 响应措施
```c
ValveControl_SetCooler(true);  // 强制开启冷却器
```

### 工作原理
1. **强制冷却**：无论PC端命令如何，直接开启冷却器
2. **持续冷却**：只要温度>120°C，冷却器一直开启
3. **自动恢复**：温度降低后，由PC端控制冷却器

### 响应时间
- **检测周期**：50ms
- **执行时间**：<1ms（GPIO直接控制）
- **总响应时间**：<51ms

### 应用场景
- 长时间高负荷运行
- 环境温度过高
- 冷却系统故障
- PC端控制失效

### 温度分级策略
| 温度范围 | 处理方式 | 位置 |
|---------|---------|------|
| < 90°C | 正常运行 | - |
| 90-120°C | PC端控制冷却 | PC端 |
| > 120°C | **强制冷却** | **嵌入式** |

---

## ⚠️ 第3层：传感器故障保护

### 触发条件
```c
if (!Sensor_CheckDataValidity())
```

### 传感器有效性判断
`Sensor_CheckDataValidity()` 检查4个传感器：
```c
bool Sensor_CheckDataValidity(void) {
    return g_sensor_monitor.validity.oil_temp_valid &&      // 油温有效
           g_sensor_monitor.validity.lng_temp_valid &&      // LNG温度有效
           g_sensor_monitor.validity.oil_pressure_valid &&  // 油压有效
           g_sensor_monitor.validity.lng_pressure_valid;    // LNG压力有效
}
```

### 故障判断标准
传感器在以下情况被判定为无效：
1. **ADC读取失败**：读取超时或硬件错误
2. **数值超出物理范围**：
   - 油温：< -100°C 或 > 150°C
   - LNG温度：< -100°C 或 > 150°C
   - 油压：< -1 MPa 或 > 50 MPa
   - LNG压力：< -1 MPa 或 > 60 MPa
3. **连续读取异常值**：连续3次无效

### 响应措施
```c
ValveControl_SetBypassValve(0.0f);        // 旁通阀关闭
ValveControl_SetDirectionalValve(false);  // 换向阀关闭
ValveControl_SetCooler(false);            // 冷却器关闭
```

### 工作原理
**"失效安全"策略**：
- 传感器数据不可信 → 无法判断系统状态 → **安全关闭**
- 所有执行器停止工作
- 避免在未知状态下继续运行

### 响应时间
- **检测周期**：50ms
- **执行时间**：<1ms
- **总响应时间**：<51ms

### 应用场景
- 传感器线路断开
- 传感器芯片损坏
- ADC模块故障
- 电磁干扰导致数据异常

---

## ⏱️ 第4层：PC命令超时保护

### 触发条件
```c
if (last_pc_cmd_time > 0 && 
    (current_time - last_pc_cmd_time) > PC_CMD_TIMEOUT_MS)
```
- `PC_CMD_TIMEOUT_MS = 1000` - 超时时间1秒
- `last_pc_cmd_time` - 上次接收PC命令的时间戳

### 工作原理

#### 正常流程
```
1. PC发送控制命令 (CAN_MSG_GCU_CONTROL_ID)
   ↓
2. CAN_RxCallback接收并更新时间戳
   last_pc_cmd_time = OSIF_GetMilliseconds()
   ↓
3. 执行控制命令（旁通阀、换向阀等）
   ↓
4. 50ms后检查超时：OK，继续运行
```

#### 超时流程
```
1. PC端程序崩溃/断开/卡死
   ↓
2. 超过1秒未收到命令
   ↓
3. 检测到：current_time - last_pc_cmd_time > 1000ms
   ↓
4. 进入安全模式：关闭所有执行器
```

### 响应措施
```c
ValveControl_SetBypassValve(0.0f);
ValveControl_SetDirectionalValve(false);
ValveControl_SetCooler(false);
printf("[SAFETY] PC command timeout! Safe mode activated\r\n");
last_pc_cmd_time = 0;  // 重置，避免重复打印
```

### 超时恢复
- PC端重新发送命令 → `last_pc_cmd_time` 更新
- 自动退出安全模式
- 恢复正常控制

### 时间轴示例
```
时间(ms)    事件
0          PC发送命令#1, last_pc_cmd_time=0
50         检查超时：0-0=0ms < 1000ms, OK
100        PC发送命令#2, last_pc_cmd_time=100
200        检查超时：200-100=100ms < 1000ms, OK
300        检查超时：300-100=200ms < 1000ms, OK
...
1100       检查超时：1100-100=1000ms >= 1000ms, 超时！
1100       ❌ 进入安全模式
1200       PC恢复，发送命令#3, last_pc_cmd_time=1200
1250       检查超时：1250-1200=50ms < 1000ms, OK
1250       ✅ 退出安全模式
```

### 应用场景
- PC程序崩溃
- CAN总线断开
- PC端硬件故障
- 网络延迟过大
- 调试时PC端暂停

### 设计考虑

#### 为什么选择1秒？
- **太短**（如100ms）：正常网络抖动可能触发
- **太长**（如5秒）：危险状态持续时间过长
- **1秒**：平衡了可靠性和安全性

#### 首次启动处理
```c
if (last_pc_cmd_time > 0 && ...)
```
- `last_pc_cmd_time=0`：初始状态，不触发超时
- 收到第一条PC命令后，才开始计时

---

## 🔧 第5层：硬件故障检测

### 触发条件
```c
if (!ValveControl_CheckHardwareStatus())
```

### 硬件状态检查
`ValveControl_CheckHardwareStatus()` 检查执行器硬件：

```c
bool ValveControl_CheckHardwareStatus(void)
{
    // 检查项目：
    // 1. PWM模块是否正常工作
    // 2. GPIO端口是否响应
    // 3. 硬件错误计数是否超限
    // 4. 执行器反馈是否正常
    
    return hardware_ok;
}
```

### 检测内容

#### 1. PWM模块检查（旁通阀）
- PWM频率是否正常
- 占空比设置是否生效
- PWM计数器是否运行

#### 2. GPIO端口检查（换向阀、冷却器）
- 输出电平是否正确
- 端口是否响应写操作
- 是否存在短路/开路

#### 3. 硬件错误计数
```c
static uint32_t error_count = 0;

if (hardware_error_detected) {
    error_count++;
    if (error_count > 10) {
        return false;  // 硬件故障
    }
} else {
    error_count = 0;  // 正常，清零
}
```

#### 4. 执行器反馈（如果有）
- 阀位置传感器反馈
- 电流检测
- 温度监控

### 响应措施
```c
ValveControl_SetBypassValve(0.0f);
ValveControl_SetDirectionalValve(false);
printf("[SAFETY] Hardware fault detected! Actuators disabled\r\n");
```

### 工作原理
- **预防性保护**：在硬件损坏扩大前停止
- **避免二次损害**：停止可能加剧故障的操作
- **便于维修**：保留故障状态，便于排查

### 响应时间
- **检测周期**：50ms
- **执行时间**：<1ms
- **总响应时间**：<51ms

### 应用场景
- PWM模块故障
- GPIO端口损坏
- 驱动电路故障
- 执行器卡死
- 电源异常

---

## 🎯 5层保护的协同工作

### 优先级顺序
```
高 ↑
   │
   ├─ 第3层：传感器故障 (最高优先级)
   │  └─ 无传感器 = 无法判断 → 立即停止
   │
   ├─ 第5层：硬件故障
   │  └─ 硬件损坏 → 停止使用
   │
   ├─ 第1层：超压保护
   │  └─ 紧急泄压 → 防止爆管
   │
   ├─ 第2层：超温保护
   │  └─ 强制冷却 → 防止烧毁
   │
   └─ 第4层：PC超时保护
      └─ 通信失败 → 安全停机
   ↓
低
```

### 执行流程
```c
void Task_50ms_SafetyCheck(void)
{
    // 所有保护并行执行，不会互相屏蔽
    
    /* 1. 超压保护 */
    if (oil_pressure > 45.0f) { ... }
    
    /* 2. 超温保护 */
    if (oil_temperature > 120.0f) { ... }
    
    /* 3. 传感器故障保护 */
    if (!sensor_valid) { ... }
    
    /* 4. PC命令超时保护 */
    if (pc_timeout) { ... }
    
    /* 5. 硬件故障检测 */
    if (!hardware_ok) { ... }
}
```

### 多重触发示例

**场景：系统同时出现高压+高温**
```
检测：
- 油压 = 46 MPa (超压！)
- 油温 = 125°C (超温！)

响应：
1. 超压保护触发：旁通阀全开 → 压力释放
2. 超温保护触发：冷却器开启 → 温度下降
3. 两个保护同时生效，不冲突

结果：
- 旁通阀：100% (超压保护)
- 冷却器：ON (超温保护)
- 换向阀：OFF (超压保护)
```

---

## 📊 保护效果对比

### 平台无关化前后对比

| 保护项 | 平台无关化前 | 平台无关化后 | 变化 |
|--------|-------------|-------------|------|
| **超压保护** | ✅ 嵌入式 | ✅ 嵌入式 | 保持 |
| **超温保护** | ✅ 嵌入式 | ✅ 嵌入式 | 保持 |
| **传感器故障** | ✅ 嵌入式 | ✅ 嵌入式 | 保持 |
| **PC超时保护** | ❌ 无 | ✅ **新增** | **增强** |
| **硬件故障** | ⚠️ 部分 | ✅ 完善 | **增强** |
| **控制算法** | ✅ 嵌入式 | ❌ 移除 | 简化 |
| **响应时间** | <1ms | <51ms | 可接受 |

### 安全性评估
```
平台无关化前：
✅ 本地控制，响应快 (<1ms)
⚠️ 算法复杂，可能有bug
⚠️ 调试困难

平台无关化后：
✅ 所有硬件保护保留
✅ 新增PC超时保护
✅ 完善硬件故障检测
✅ 算法在PC端，调试方便
⚠️ 响应时间稍长 (<51ms，可接受)
```

**结论：安全性不降反升！**

---

## 🔍 故障排查流程

### 当系统进入安全模式时

#### 1. 检查串口输出
```
[SAFETY] Over-pressure detected!          → 超压保护
[SAFETY] Over-temperature detected!       → 超温保护
[SAFETY] Sensor fault detected!           → 传感器故障
[SAFETY] PC command timeout!              → PC超时
[SAFETY] Hardware fault detected!         → 硬件故障
```

#### 2. 排查步骤

**超压保护触发：**
1. 检查压力传感器读数
2. 检查旁通阀是否打开
3. 检查系统是否有泄漏
4. 检查负载是否异常

**超温保护触发：**
1. 检查温度传感器读数
2. 检查冷却器是否工作
3. 检查环境温度
4. 检查液压油状况

**传感器故障触发：**
1. 检查传感器线路
2. 检查ADC模块
3. 检查传感器供电
4. 更换传感器测试

**PC超时触发：**
1. 检查CAN总线连接
2. 检查PC程序运行状态
3. 检查CAN波特率
4. 重启PC控制程序

**硬件故障触发：**
1. 检查PWM输出
2. 检查GPIO状态
3. 检查驱动电路
4. 检查执行器

---

## 💡 最佳实践

### 开发阶段
```c
// 可以临时调整阈值用于测试
#define PRESSURE_LIMIT_TEST  40.0f  // 测试用（正式：45.0f）
#define TEMP_LIMIT_TEST     110.0f  // 测试用（正式：120.0f）
```

### 生产环境
```c
// 使用正式阈值
#define PRESSURE_LIMIT  45.0f   // 留5MPa余量
#define TEMP_LIMIT     120.0f   // 留30°C余量
#define PC_TIMEOUT_MS   1000    // 1秒超时
```

### 调试建议
1. **逐个测试保护机制**
   - 模拟超压（安全环境）
   - 模拟超温（加热测试）
   - 拔掉传感器线（传感器故障）
   - 断开CAN线（PC超时）

2. **记录保护触发**
   - 保存触发时的所有传感器数据
   - 记录触发时间和频率
   - 分析保护是否正常工作

3. **设置合理阈值**
   - 根据实际工况调整
   - 留有足够安全余量
   - 避免误触发

---

## 📋 总结

### 5层保护的核心价值

1. **多重安全**：5层独立保护，互为补充
2. **快速响应**：<51ms检测和执行
3. **失效安全**：任何异常都会安全关闭
4. **容错设计**：PC端故障不影响安全
5. **易于调试**：清晰的故障提示

### 关键设计原则

✅ **独立性**：每层保护独立判断，独立执行  
✅ **并行性**：5层同时检查，不互相屏蔽  
✅ **保守性**：宁可误触发，不可漏保护  
✅ **可恢复**：故障消除后自动恢复  
✅ **可观测**：所有保护都有日志输出  

---

**这5层安全保护确保了即使在平台无关化后，嵌入式系统仍然具有完整的硬件级安全保障！** 🛡️

